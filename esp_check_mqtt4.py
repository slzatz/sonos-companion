#!bin/python
'''
This is a python 3.x script that is usually run  on a raspberry pi
and is connected to sonos so it can issue sonos commands like changing
the volume and pausing the music
This script subscribes to mqtt messages  that are generated by 
devices like the esp32-based m5stack and its sonos_remote_m5stack.py script
Those mqtt messages are sent to the mqtt broker running on ec2 box and this script subscribes
to that topic, which is sonos/{location}
'''
import os
from time import sleep
import json
import sys
home = os.path.split(os.getcwd())[0]
sys.path = [os.path.join(home, 'SoCo')] + sys.path
import soco
from soco import config as soco_config
import paho.mqtt.client as mqtt
from config import aws_mqtt_uri, location
import sonos_actions

soco_config.CACHE_ENABLED = False

n = 0
while 1:
    n+=1
    print("attempt "+str(n))
    try:
        sp = soco.discover(timeout=2)
        speakers = {s.player_name:s for s in sp}
    except TypeError as e:    
        print(e) 
        sleep(1)       
    else:
        break 
    
for s in sp:
    print("{} -- coordinator:{}".format(s.player_name.encode('ascii', 'ignore'), s.group.coordinator.player_name.encode('ascii', 'ignore'))) 

master_name = input("Which speaker do you want to be master? ")
master = sonos_actions.master = speakers.get(master_name)
if master:
    print("Master speaker is: {}".format(master.player_name))
    sp = [s for s in sp if s.group.coordinator is master]
    print("Master group:")
    for s in sp:
        print("{} -- coordinator:{}".format(s.player_name.encode('ascii', 'ignore'), s.group.coordinator.player_name.encode('ascii', 'ignore')))

else:
    print("Somehow you didn't pick a master or spell it correctly (case matters)")
    sys.exit(1)

def on_connect(client, userdata, flags, rc):
    print("Connected with result code "+str(rc))

    # Subscribing in on_connect() means that if we lose the connection and
    # reconnect then subscriptions will be renewed.
    # client.subscribe("$SYS/#")
    client.subscribe('sonos/'+location)

# The callback for when a PUBLISH message is received from the server.
def on_message(client, userdata, msg):
    print(msg.topic+" "+str(msg.payload))
    body = msg.payload
    print("mqtt messge body =", body)

    try:
        task = json.loads(body)
    except Exception as e:
        print("error reading the mqtt message body: ", e)
        return

    action = task.get('action', '')

    if action == 'play_pause':
    
        try:
            state = master.get_current_transport_info()['current_transport_state']
        except Exception as e:
            print("Encountered error in state = master.get_current_transport_info(): ", e)
            state = 'ERROR'

        # check if sonos is playing music
        if state == 'PLAYING':
            master.pause()
        elif state!='ERROR':
            master.play()

    elif action in ('quieter','louder'):
        
        for s in sp:
            s.volume = s.volume - 10 if action=='quieter' else s.volume + 10

        print("I tried to make the volume "+action)

    elif action == "volume": #{"action":"volume", "level":70}

        level = task.get("level", 500)
        level = int(round(level/10, -1))

        if level < 70:

            for s in sp:
                s.volume = level

            print("I changed the volume to:", level)
        else:
            print("Volume was too high:", level)

    elif action == "play_wnyc":
        sonos_actions.play_station('wnyc')

    elif action.startswith("station"):
        station = action[8:]
        sonos_actions.play_station(station)

    elif action.startswith("shuffle"):
        artist = action[8:]
        sonos_actions.shuffle(artist)

    elif action == "play_queue":
        queue = master.get_queue()
        if len(queue) != 0:
            master.stop()
            master.play_from_queue(0)

    else:
        print("I have no idea what you said")

client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message
client.connect(aws_mqtt_uri, 1883, 60)
client.loop_forever()
# could also call while 1: client.loop() sleep(1) so could do other things in loop. Not sure what timeout should be set to if we call loop "manually"
